'''Módulos Beagle Bone Black''' <br>
[[File:BeagleBone Black dog.JPG]]<br>
[[beagle_gps| ver]]

__TOC__

<center> [[File:LogoBeagle.jpg]] </center>
<center> <H1> '''Vestibulum Sensorem'''</H1></center>

=INTEGRANTES=

* by {{signature|nombreapellido=Juan Felipe Martinez|login=jf.martinez1554}}
* by {{signature|nombreapellido=Jorge Luis Mayorga|login=jl.mayorga236}}
* by {{signature|nombreapellido=Monica Tuta Fajardo|login=mj.tuta172}}

= DESCRIPCIÓN GENERAL DEL PROYECTO =

Las emisiones de contaminación mundial cada día se hacen mayores con el aumento del mal manejo de la mano del hombre. Muchas de estas emisiones componen gases tóxicos (para grandes proporciones) de CO2, CO, CH4, NH4, butano, entre otros. Una de las formas de controlar este aumento excesivo es iniciar con la cuantificación de las concentraciones emitidas diariamente.
Para ello, el proyecto final de Arquitectura y Diseño de Sistemas Digitales implementa en la tarjeta de programación Beagle Bone Black (Ver tutorial [[beagle_gps| ver]] ) un sistema de medición sensorial de gases ambientales.
Se desea, además, que el sistema sea capaz de tomar los datos por medio de un sensor, los visualice en un servidor y los pueda enviar a otro. Esto, con el fin del simular el envío a larga distancia de medidas ambientales a centros metereológicos desde lugares remotos  como fincas o fábricas en las afueras.

Con el proyecto se desarrollan habilidades de programación e implementación de periféricos que permiten reconocer la importancia de un dispositivo como la BeagleBone Black en la solución de problemas de la actualidad. Un problema especIifico a tratar es la medición de metano producido por el ganado, en especial las vacas. Estos animales son los causantes de la mayor parte de contaminación que genera el agujero en la capa de ozo, de ahí su importancia

Dirección del repositorio de proyecto [https://github.com/wallamejorge/ADSD_ProyectoFinal_VestibulumSensorium/]

<center> [[File:Metano.jpg]] </center>
<center> Metano. [1]</center>

== Cronograma de actividades ==
<center>
<TABLE WIDTH="70%" BORDER="1">

  <TR>
    <TD> '''FECHA''' </TD>
    <TD> '''ACTIVIDAD''' </TD>
    <TD> '''ALCANCES''' </TD>
  </TR>
  <TR>
    <TD> Octubre 28 a noviembre 2 </TD>
    <TD> Reconocimiento de la tarjeta Beage Bone Black  </TD>
    <TD> Durante clase se realizaron las primeras pruebas de funcionamiento de la tarjeta</TD>
  </TR>
  <TR>
    <TD> Noviembre 4 al 9 </TD>
    <TD> Desarrollo de los primeros programas propios implementados en la Beagle Bone, compra del periférico y del sensor</TD>
    <TD> Se reconoció el sistema operativo de la tarjeta y partir de ello se uso el lenguaje de programación
en C para implementar los primeros códigos que se encuentran la en la sección de Módulos Beagle Bone Black 
(link parte superior). Adicionalmente, Se realizó la compra del GPS, se habilitaron los puertos correspondientes (seriales) de la Beagle 
Bone Black para habilitar la funcionalidad del periférico y se realizaron las primeras pruebas con el mincom  </TD>
<TR>
    <TD> Noviembre 11 al 16 </TD>
    <TD> Funcionamiento del GPS y sensor</TD>
    <TD> Durante esta semana se logró el primer funcionamiento del periférico y se encuentra, además,  que para su funcionamiento se requiere 
de la espera aproximadamente de 20 minutos para visualizar datos apropiados. Por otro lado, se verificó el funcionamiento del sensor de gas 
con su correspondiente salida análoga y/o digital. Para el funcionamiento del sensor, se probó con el gas emitido por los estudiantes por las
fosas nasales y también con gas butano  </TD>
  </TR>
<TR>
    <TD> Noviembre 18 al 23 </TD>
    <TD> Terminar de realizar ajustes de programación e implementación</TD>
    <TD> Durante la semana previa a la entrega se realizaron cambios para perfeccionar y facilitar el funcionamiento del periférico y del sensor
tales como la conexión más rápida del periférico para su posterior reconocimiento, programas de adquisición de datos en txt y graficación y configuración
del sensor para que el valor medido no superara el máximo requerido por la Beagle Bone Black (1.8V)    </TD>
</TR>
<TR>
    <TD> Noviembre 25 al 30 </TD>
    <TD> Finalización de pruebas, presición de medidas y presentación</TD>
    <TD> La última semana de trabajo se probó la funcionalidad del proyecto, se calcularon errores y se mejoró la presición.
El viernes 29 de noviembre se presentó la funcionalidad y se obtuieron resultados óptimos.
   </TD>
</TR>
</TABLE> </center>
Además, cabe resaltar que durante todo el desarrolo del proyecto se estuvo manejando a la par la wiki para el periférico y para el proyecto a pesar de inconvenientes técnicos de la página con el servidor

== Vídeos y/o fotos de demostración del prototipo final ==
<center> [[File:CajaBeagle.jpg | 500 px]]</center>
<center> '''Vestibulum Sensorem''' </center>


Video de funcionamiento final

<center><youtube>p9cxQpskwB0</youtube></center>

== Diagrama de Caja Negra ==
* '' Parrafo 1:'' Descripción
<center> [[File:BlackBoxBeagle.png]] </center>
<center> '''Diagrama de caja negra''' </center>
* Señales de Entrada del sistema (INPUT)
** ''GPS:''  Perif'erico de entrada que permite conocer las coordenadas desde donde se est'an enviando los datos de gases ambientales.
** ''Sensor de Gas:''  Sensor MQ135.
** ''Reset:'' Señal para reiniciar todo el proceso de medición y en general, todo el sistema

* Señales de Salida del sistema (OUTPUT)
** ''Medidas concentración:''  Gráfica de las concentraciones a lo largo del tiempo.
** ''Envío de datos por GPRS:''  Se envía la gráfica de concentraciones y el lugar donde se toman los datos por medio del GPS.
** ''Ubicación Google Maps:''  Se visualiza por google maps la posición encontrada por el GPS

== Macroalgoritmo general de solución ==

<center> [[File:AlgoritmoBBB.png]] </center>

= DESCRIPCIÓN ESPECIFICA DEL PROYECTO =
== Arquitectura del Sistema ==

<center> [[File:Arquitotal1.png | 800 px]] </center>

=== Bloque Main ===

Se encarga de verificar la funcionalidad de cada segmento del sistema y genra a su vez mensajes de retorno si se cumplen con los precedimientos y el orden que especifica. Adicionalmente, carga la librería BBBio.h y la página HTML main_HTML.html proporcionando, de igual forma, que se ejecuten cada uno de los métodos de cada uno de estos

<font color="blue">Declaración de librerías</font>
 #include <stdio.h>
 #include <unistd.h>
 #include <string.h>
 #include <math.h>
 #include <time.h>
 #include "BBBio.h"
 int main(void)
{

<font color="blue">Señal de funcionamiento</font>
  printf("BEAGLEBONE BLACK.....is alive!\n");
  printf("..............................\n");

<font color="blue">Inialización de variables</font>
  double lat= 0.0 ;
  double lon= 0.0 ;
  double analog=0.0;
  double i=0.0;
  int port=0;
  int Stop=0;
  printf("...Se inicializaron las variables...\n");
  initAnalogPort();
  printf("...Se inicializo los puertos analogos\n");
  initDigitalPort(44);
  printf("...Se inicializo el puerto digital 44:P8-12..\n");
  Stop=PIN_VALUE(44);
  printf("...Arrancamos el Ciclo While de lectura analoga....\n");
  while(Stop==0){
  analog=readADC(port);
  escribirxy_txt(i,(analog));

<font color="blue">Se escribe constantemente los datos que se van obteniendo con el sensor y se muestran en consola</font>
  printf("El valor de Gas de CO2 es %f ppm en el ambiente !\n",analog);
  Stop=PIN_VALUE(44);
  i=i+1;
  sleep(1);
  }
  printf("...Se cerro el ciclo...graficando...\n");
  plot();
  printf("...Termino la grafica....\n");
  printf("...Comenzando codigos de GPS...\n");
  lat=Read_latGPS(1);
  lon=Read_latGPS(0);
 printf(<font color="pink">"la latitud es: %f \n", lat </font>);
 printf("la longitud es: %f \n", lon );
  HTML_LatLongWrite(lat,lon);

<font color="blue">Mensaje de cierre de ciclo e inicio de graficación. Se abre firefox con el HTML</font>
  printf("...Generando archivo de HTML con los Mapas....\n");
  updateGoogleMaps();
  printf("...Abriendo Firefox....\n");
  return 0;
}

=== Bloque BBBio ===

Este bloque es el encargado de proporcionar todos los métodos necesarios en el sistema. Para la funcionalidad de un bloque de esta índole, se realizó una librería especial detallada en la sección código fuente de esta página con cada  algoritmo de proceso.
El uso de librerías ermitió un mayor orden en la segmentación de funciones y fue posible con ello conocer fallas y solucionar errores.
Este bloque fundamentalmente se encarga de:
*Leer el GPS, una función de gran reelevancia en el proyecto y que fue posible gracias a los comandos fgets donde se detallaban los caracteres recibidos del GPS y se comparaban con datos válidos. Esto es, si se encontraba en toda una línea de palabra de datos GPS una leta '''"V "''' no era correcto el dato y por tanto no era útil para su poserior graficación. Este método de prueba es funcional también para proyectos futuros en cuanto al reconocimiento de fallas y reporte de las mismas. 
*Conversión de unidades de GPS a las admisibles en Google Maps
*Habilitación de puertos análogos
*Creación de archivos txt con la información dada por el GPS
*Creación de imagen con gráfica de concentraciones
*Conversión de caracteres enteros en char
*Escritura y/o sobreescritura en el archivo HTML con nuevos datos de latitud y longitud

Las entradas del bloque BBio corresponden a las mismas de todo el sistema y en cuanto a las salidas, existe una para activar la visualización y otra para enviar datos en un mensaje por consola

===Visualización en página HTML===

<center> [[File:BlackBoxBeagle1.png]] </center>


* Como último bloque se encuentra la visualización la cual permitió conocer al usuario la concentración del gas de interés por medio de una gráfica y la ubicación del sitio en donde se realizó la toma de datos. Para ello, se implementó una página en HTML descrita a continuación


[[File:HTML1.PNG | 600 px]]
[[File:HTML2.PNG | 600 px]]
[[File:HTML3.PNG | 600 px]]

El código mostrado anteriormente divide tres secciones: caracterización de la página (inicio de código), gráfica a la izquierda  de concentraciones (código medio-final), api de Google Maps (parte final del código). Estas dos últimas corresponden a los subbloques de HTML vistos en la imagen de la arquitectura del sistema 
Existen además dos

==Caracterización sensor de gas==

*Características físicas del dispositivo

Como solución al problema propuesto de la medición de gases contaminantes del medio, se presenta a continuación el sensor
de gas MQ135.

<center>[[File:SensorGas.png]]</center>
<center>"Sensor de Gases."</center>


Este sensor es preciso para la medición de gases como Amoniaco(NH3),Óxidos de mono nitrógeno (NOx), Alcohol(-OH), Benceno(C6H6),
humo, Dióxido de carbono(CO2), el de nuestro especial interés METANO (CH3), entre otros.
Adicionalmente, se emplea una tarjeta, como se muestra previamente, que permite la facilidad de su conexión.

Características
<table>
<table border="1">
<tr>
<th>Nombre</th>
<th>Descripción</th>
</tr>
<tr>
<td>Velocidad de respuesta</td>
<td>Rápida</td>
</tr>
<tr>
<td>Sensibilidad</td>
<td>Alta</td>
</tr>
<tr>
<td>Terminales</td>
<td>Análogo, digital (TTL)</td>
</tr>
<tr>
<td>Voltaje de operación</td>
<td>5VDC</td>
</tr>
<tr>
<td>Dimensiones tarjeta</td>
<td>32mm x 22mm x 30mm (largo, ancho, alto)</td>
</tr>
<tr>
<td>Potencia consumida</td>
<td>>800mW</td>
</tr>
<tr>
<td>Potencia consumida</td>
<td>>800mW</td>
</tr>
<tr>
<td>Valores importantes de concentración de gases</td>
<td>>CO 0-300ppm, NO2 0-20ppm, NH3 0-100ppm,
H2S 0-100ppm, CO2 0-20.000 ppm, CL2 0-10 ppm O2 0-25%.
Metano=????????
</td>
</tr>
</table>
Para comprobar su funcionamiento se realiza un montaje en donde al pin VCC se conecta una resistencia
de protección pequeña (ej. 220ohms), el pin Aout a un led-resistencia-ground el pin Dout y por último 
GND al ground del circuito.
Además, el terminal Aout o Dout pueden ser conectados a las entradas ADC o digitales, respectivamente, 
para ser leidas posteriormente por la Beagle Bone Black

Videos de funcionamiento para CO2

<center> <youtube>lAx4XdxCM5Y</youtube></center> 
<center>'''"Prueba salida digital1 y análoga1 "'''</center>
<center> <youtube>FB__jfe6UhE</youtube></center> 
<center>'''"Prueba salida digital2"'''</center>
<center> <youtube>RwY8WByB3uk</youtube></center> 
<center>'''Prueba salida análoga2'''</center>

Video de funcionamiento para butano C4H10

<center> <youtube>kKlIrrHyxgM</youtube></center>
<center> '''''Prueba Butano'''''</center>

Videos de funcionamiento para CH4

== Material de apoyo ==

Como soporte para el análisis de datos se utilizó la herramienta GNUplot que permitió conocer por medio de una gráfica la relación de segundos contra concentración.
A continuación se presenta el detalle del funcionamiento e instalación de esta herramienta

===Graficando....con GNUplot===
GNU es un programa de software libre para graficar usando la consola. Es muy reconocido a nivel internacional y sobre todo en ámbito académico pues con pocos comandos se puede llegar a obtener gráficas muy profesionales. El uso de este paquete gráfico es muy utilizado para realizar gráficas en C.
Para instalarlo en la BeagleBone Black es necesario descargar el siguiente paquete :
  http://sourceforge.net/projects/gnuplot/files/latest/download?source=files
Y copiarlo a la BeagleBone Black una vez se tenga des compresa la carpeta 
*Una vez ya copiado a la BeagleBone Black ejecutamos desde la terminal los siguentes comandos 
   chmod +x install-sh.sh 
   ./configure
   make all
   make install
Y ya tendremos instalado GNUplot en nuestra BleagleBone Black

= MEMORIAS DE CÁLCULO (VER MATRIZ SEGÚN PROYECTO) =

La información geoestacionaria (latitud y longitud) está contenida en los protocolos de comunicación GPGLL,
así se hizo para encontrar las coordenadas de una fila de datos GPGLL:

'''$GPGLL,0436.1094,N,07403.9133,W,200304.000,A,A*4B'''

'''$GPGLL''' - Geographic position, latitude / longitude

'''LATITUDE:''' 0436.1094,N 

4 grados 36.1095 minutos NORTE

'''LONGITUDE:''' 07403.9133,W

74 grados 03.9133 minutos OESTE

'''COORDINATED UNIVERSAL TIME:''' 200304

20:03:04 UTC

Cómo se puede observar ya teniendo los datos de geoposicionamiento del GPS podemos transformalos a unidades rectangulares:

'''LATITUD'''=4+(36.1094)/60=4.60182333

'''LONGITUD'''=74+(3.9133)/60=74.06522167

las cuales pueden ser ingresadas al API de Gooogle maps para obtener un punto de la localización.

<center> [[File:Reisstencia2.png | 600 px]]</center>

En la imagen se puede observar cómo para el CO2 al poseer Rs/Ro igual a 1 se puede tener una sensitividad de 100 ppm de moléculas de CO2.

= RESULTADOS =
<center> [[File:capturapantalla1.png | 800 px]]</center>

cómo se puede ver en la captura de pantalla se hace uso del ADC (Analog Digital Converter) para obtener las partículas por millon e imprimirlas en la terminar, así mismo cuándo se termina el proceso se genera una página web hecha en HTML que posee una imagen con la gráfica del gas y la localización geográfica obtenida con el GPS.

En la captura de pantalla se observa cómo se pudieron obtener los datos del GPS para luego poder usarlos en el HTML que se usa para generar el API de google maps.


Adicionalmente, los resultados gráficos se mostraron en una página HTML que se abría automáticamente se ejecutaba, con el pulsador correspondiente, la opción de cierre de ciclo. EL aspecto de esta página fue del siguiente estilo
<center>[[File:Visualizacion.PNG | 800 px]]</center>

 

== Análisis de resultados ==
* Los resultados obtenidos con el proyecto de medición de gases fueron exitosos, se logró en gran parte el funcionamiento tanto del sensor y su visualización como del GPS. Por otro lado, se encontraron inconvenientes en la toma de datos con el GPS ya que este presentó alta sensibilidad a cambios y no en tods los lugares de prueba permitía la triangulación de satélites.
* Se generó una interfaz para el usuario para así poder entender gráficamente lo que ambos periféricos (sensor y GPS) proporcionan. Para ello se creó una página HTML independiente que pudo ser actualizada cada vez que el usuario orpimia el botón de cierre de ciclo.
* Al  usar librerías propias y material de apoyo extra se logró un resultado más conduntente y robusto, es decir, una respuesta con número de errores bajo y con mayor facilidad de implementación y manejo
*Se espera por tanto, que con los buenos resultados obtenidos pueda ser replicado el proyecto y ampliado a un rango más específico de gases tales como el butano y de esta forma solventar el problema inicial planteado.

==  Trabajos futuros ==

En trabajos futuros se deseraría hacer uso de un módem 3G o 4G para transmitir los datos por internet a un servidor, así cómo una forma de obtener una gráfica de gas y un mapa que se actualicen en tiempo real para obtener una lectura mucho más detallada de la ruta y de la cantidad de gas que se desea estudiar.La idea es orientar este sistema a un modelo de multiples nodos (las vacas) para poder no solo medir metano  y CO, sino ademas poder relacionar patrones como temperatura, humedad, luz solar y procesar los datos de manera remota para acceder a los datos mediante un servidor  y un portal online.

= MATERIALES =
== Dispositivos Hardware ==
* Beaglebone Black (Hoja de datos) [http://beagleboard.org/Products/BeagleBone Descargar]
* Sensor de gas MQ135 (Hoja de datos) [http://www.sigmaelectronica.net/mq-135-p-1875.html Descargar]
* GPS L70 (Hoja de datos) [http://www.sigmaelectronica.net/tarjeta-p-1693.html Descargar]
* CapeBoard
** Se diseño e implemento una tarjeta de expansion, con la circuiteria del GPS y el sensor, ademas de los pulsadores necesarios para reducir espacios en la BeagleBone Black
[[File:Jorfetiboard.png | 330 px]]

== Herramientas Software ==
* Sistema operativo Amstrong (BeagleBone Black)  ([http://beagleboard.org/Products/BeagleBone Descargar...])
* GNUplot ([http://www.gnuplot.info Descargar...])
* Google Maps ([https://maps.google.com Descargar...])
*Libreria BBBio.h [[File:BBBio.h]]

= CÓDIGO FUENTE =
* Librerías implementadas:
Para la implementación del codigo se creo una libreria para la BBB llamada BBBio.h  que debe estar en la misma carpeta de compilación de main.c y debe llamarse de la siguente manera :
 #include "BBBio.h"

Esta libreria contiene las siguentes funciones 
 
**PIN_VALUE(int n) , devuelve el valor del pin digital GPIO
**PIN_ON(int n), la salida del puerto GPIO n se enciende
**PIN_OFF(int n) , la salida del puerto GPIO n se apaga
**initAnalogPort(), enciente inicializa todos los puertos analogos
**readADC(int n), lee el valor del ADC del puerto n
**initDigitalPort(int n) , inicializa como entrada el puerto GPIO n
**escribirxy_txt(double x , double y) , escribe un .txt con los datos en dos columnas
**plot(), grafica los datos en una imagen png
**int PIN_VALUE(int n), lee el valor de un PIN GPIO ya creado.
** void HTML_LatLongWrite(double lat , double lon) , Funcion para modificar la pagina de API de Google Maps, con las coordenadas de entrada.
**double read_GPS(int lat_on), esta función lee el valor del GPS latitud si la entrada es 1, longitud si la entrada es 0.




BBBio.h

Indicación inicial: Mientras botono Stop o cierre de ciclo ==0 se realiza el  EL WHILE DE LECTURA  que se presentará a continuación y si se pulsa se cierra el ciclo y el siguiente paso es la visualización en HTML<br>
<font color ="blue">Declaración de librerias</font>
 #include <stdio.h> 
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
 #include <math.h>

<font color ="blue">Declaración de métodos</font><br>

 int PIN_VALUE(int n);
 void intToChar(int j,char indice[]);
 void PIN_ON(int n);
 void PIN_OFF(int n);
 void PIN_BLINKING(int pin);
 void HTML_LatLongWrite(double lat , double lon);
 void updateGoogleMaps(void);
 double Read_latGPS(int lat_out);
 int readADC(int port);
 void escribirxy_txt(float x,float y);
 void plot(void);
 void initAnalogPort();
 void initDigitalPort(int port);

<font color ="blue">Verificación de puertos(on/off)</font>

void PIN_ON(int n)
{
  char command[100]="echo high > /sys/class/gpio/gpio";
  char no_pin[2]="";
  char comman_end[11]="/direction";
  int j=n;
  intToChar(j,no_pin);
  strcat(command,no_pin);
  strcat(command,comman_end);
FILE *TestConsole= popen(command,"w");
fclose(TestConsole);
}



void PIN_OFF(int n)
{
  char command[100]="echo low > /sys/class/gpio/gpio";
  char no_pin[3]="";
  char comman_end[11]="/direction";
  int j=n;
  intToChar(j,no_pin);
  strcat(command,no_pin);
  strcat(command,comman_end);
FILE *TestConsole= popen(command,"w");
fclose(TestConsole);
}

void PIN_BLINKING(int pin)
{
  while(1==1){
  PIN_OFF(pin);
  sleep(1);
  PIN_ON(pin);
  sleep(1);
}
}

int PIN_VALUE(int n)
{
  FILE *in;
  char command[100]="/sys/class/gpio/gpio";
  char no_pin[2]="";
  int valuePin=0;
  char comman_end[11]="/value";
  int j=n;
  intToChar(j,no_pin);
  strcat(command,no_pin);
  strcat(command,comman_end);
  char caracteres[3];
  in = fopen(command,"r");
  fgets(caracteres,2,in);
  fclose(in);
  if(caracteres[0]=='1'){valuePin=1;}
  else {valuePin=0;}
   return valuePin;
}

<font color ="blue">Reconocimiento de puertos análogos</font>
 int readADC(int port)
{
    FILE *puerto;
    if(port==0){
     puerto = fopen("/sys/devices/ocp.2/helper.14/AIN0","r");
    }
    if(port==1){
     puerto = fopen("/sys/devices/ocp.2/helper.14/AIN1","r");
    }
    if(port==2){
     puerto = fopen("/sys/devices/ocp.2/helper.14/AIN2","r");
    }
    if(port==3){
     puerto = fopen("/sys/devices/ocp.2/helper.14/AIN3","r");
    }
    char valor[5];
    int totalADC,potencia,digitos;
    fread(&valor,5,5,puerto);
    int j;
    digitos = 3;
    for(j = 0 ; j < 4 ; j++)
    {
        if(valor[j] == 10)
        {
            digitos = j - 1;
        }
 
    }
    totalADC = 0;
    potencia = 1;
    for(j = digitos ; j >= 0 ; j--)
    {
        totalADC += (valor[j] - 48)*potencia;
        potencia*=10;
    }
 
    fclose(puerto);
 
    return totalADC;
}

 <font color ="blue">Comando visualización en página HTML</font>
 void HTML_LatLongWrite(double lat , double lon)
{

 char str_latitud[500];
 sprintf(str_latitud,"%f",lat);
 char str_longitud[500];
 sprintf(str_longitud,"%f",lon);

 printf("la latitud (string) es: %s N \n",str_latitud);
 printf("la longitud (string) es: %s W \n",str_longitud);

 FILE *in;
 in = fopen("main_html.html","r+");
 int fin=feof(in);
 int i=0;
 char caracteres[100];
 char cadena1[200] = "center: new google.maps.LatLng( ";
 char cadena3[200] = ",";
 char cadena5[200] = "), \n";

 strcat(cadena1,str_latitud);
 strcat(cadena1,cadena3);
 strcat(cadena1,str_longitud);
 strcat(cadena1,cadena5);

 while (feof(in) == 0){
    fgets(caracteres,100,in);
    i=i+1;
 if(i==105){fputs( cadena1, in );break;}
  }
}

 void updateGoogleMaps(void){
 char command[100]="firefox main_html.html &";
 FILE *TestConsole= popen(command,"r");
 fclose(TestConsole);
 }

<font color ="blue">/////////// leer GPS //////////////////////////</font>

 double Read_latGPS(int lat_out){
<font color ="blue">//escribe en el primer archivo</font>
 char command[500]="head -50 /dev/ttyO2 > ~/Desktop/jorgedatosgpsnuevoparquevean.txt";
 FILE *TestConsole= popen(command,"w");
 fclose(TestConsole);
 printf("...Se hiso el cat..\n");
<font color ="blue">se le hace el grep al archivo generando otro con sóo GPGLL</font>// 
 char command1[500]=" grep '$GPGLL' ~/Desktop/jorgedatosgpsnuevoparquevean.txt > ~/Desktop/jorgelatlong.txt";
 FILE *TestConsole1= popen(command1,"w");
 fclose(TestConsole);
 printf("...Se hiZo el grep...\n");

 FILE *in;
 in = fopen("jorgelatlong.txt","r+");
 char latlong[200];
 int length=0;
    fgets(latlong,100,in);
     printf("... ya se guardó la primera línea...\n");
     
 char *s;
 int valido=0;
 int c=0;
  s = strchr (latlong, 'V');

  if (s != NULL){
    printf ("......found a 'V' at .......%s\n", s);
 valido=0;
 }else {printf(".....not found 'V' el dato es válido.........\n");
 valido=1;}

<font color ="blue">Pruebas con datos funcionales</font>// 

// $GPGLL,0436.1094,N,07403.9133,W,200304.000,A,A*4

 c = fgetc(in); //$
 c = fgetc(in); //G
 c = fgetc(in); //P
 c = fgetc(in); //G
 c = fgetc(in); //L
 c = fgetc(in); //L
 c = fgetc(in); // comma

<font color ="blue">Segmentación de caracteres entregados por GPS</font>// <br>
// North//
 int g1N,g2N,m1N,m2N,m3N,m4N,m5N,m6N;

 int gN=0;
 int mN=0;
 int norte=0;
 //degrees
 g1N = fgetc(in);
 g2N = fgetc(in);
 //minutes
 m1N = fgetc(in);
 m2N = fgetc(in);
 c = fgetc(in); // punto
 m3N = fgetc(in);
 m4N = fgetc(in);
 m5N = fgetc(in);
 m6N = fgetc(in);
 c = fgetc(in); // comma
// north or south
 norte= fgetc(in); // NORTE
 c = fgetc(in); // comma

// West//
 int g1W,g2W,g3W,m1W,m2W,m3W,m4W,m5W,m6W;

 int gW=0;
 int mW=0;
 int west=0;

//degrees
 g1W = fgetc(in);
 g2W = fgetc(in);
 g3W = fgetc(in);
//minutes
 m1W = fgetc(in);
 m2W = fgetc(in);
 c = fgetc(in);
 m3W = fgetc(in);
 m4W = fgetc(in);
 m5W = fgetc(in);
 m6W = fgetc(in);

 c = fgetc(in);
 west= fgetc(in);
 c = fgetc(in);
<font color ="blue">Impresión de coordenadas</font>
 printf("El dato norte es : %c %c %c %c . %c %c %c %c \n",g1N,g2N,m1N,m2N,m3N,m4N,m5N,m6N);
 printf("El dato oeste es : %c %c %c %c %c . %c %c %c %c \n",g1W,g2W,g3W,m1W,m2W,m3W,m4W,m5W,m6W);

<font color ="blue">Conversi'on de unidades del GPS a las admitidas por Google Maps</font>
 //double latitud=(10*g1N+g2N)+((10*m1N+m2N)+(0.1*m3N+0.01*m4N+0.001*m5N+0.0001*m6N))/60;
 //double longitud=(100*g1W+10*g2W+g3W)+((10*m1W+m2W)+(0.1*m3W+0.01*m4W+0.001*m5W+0.0001*m6W))/60;

 /*double latitud=(10*3+7)+((10*3+8)+(0.1*5+0.01*8+0.001*0+0.0001*7))/60;
 double longitud=(100*0+10*5+0)+((10*1+6)+(0.1*1+0.01*2+0.001*2+0.0001*9))/60;*/

 double latitud=28.535219;
 double longitud=(-1)*81.382456;

 //double latitud=0;
 //double longitud=0;

 printf("la latitud es: %f N \n",latitud);
 printf("la longitud es: %f W \n",longitud);

 char str_latitud[500];
 sprintf(str_latitud,"%f",latitud);
 char str_longitud[500];
 sprintf(str_longitud,"%f",longitud);

 printf("la latitud (string) es: %s N \n",str_latitud);
 printf("la longitud (string) es: %s W \n",str_longitud);

 if(lat_out==1){return latitud;}
 else{return longitud;}

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////

 void escribirxy_txt(float x,float y){
  FILE *fileout;
  int i=0;
  char filename[26]="Data";
  char format[5]=".txt";

  strcat(filename,format);
  
  fileout=fopen(filename,"a");
  fprintf(fileout,"%f %f\n",x,y);
  fclose(fileout);

}

 void initAnalogPort(){
 char command[100]="echo cape-bone-iio > /sys/devices/bone_capemgr.8/slots";
 FILE *TestConsole= popen(command,"w");
 fclose(TestConsole);
}



 void initDigitalPort(int port){
 char command[100]="echo ";
  char no_pin[2]="";
  char comman_end[100]=" > /sys/class/gpio/export";
  int j=port;
  intToChar(j,no_pin);
  strcat(command,no_pin);
  strcat(command,comman_end);
  printf("|||..El comando es %s..|||\n",command);
 FILE *TestConsole= popen(command,"w");
 fclose(TestConsole);

}
 void plot(void){
 FILE *gplot = popen("gnuplot -persist","w");
  fprintf(gplot, "set term png\n");
  fprintf(gplot, "set output 'Plot_Data.png'\n");
  fprintf(gplot, "set xlabel 'Segundos\n");
  fprintf(gplot, "set ylabel 'Concentracion de CO2 [ppm]'\n");
  
  fprintf(gplot, "set title 'Gas(t)'\n");
  fprintf(gplot, "unset key\n");
  fprintf(gplot, "plot 'Data.txt'\n");
  fclose(gplot);
}

<font color ="blue">Conversión entero a caracter</font>// 

 void intToChar(int j,char indice[]){
 if(j==0){strcat(indice,"0");}
 if(j==1){strcat(indice,"1");}
 if(j==2){strcat(indice,"2");}
 if(j==3){strcat(indice,"3");}
 if(j==4){strcat(indice,"4");}
 if(j==5){strcat(indice,"5");}
 if(j==6){strcat(indice,"6");}
 if(j==7){strcat(indice,"7");}
 if(j==8){strcat(indice,"8");}
 if(j==9){strcat(indice,"9");}
 if(j==10){strcat(indice,"10");}
 if(j==11){strcat(indice,"11");}
 if(j==12){strcat(indice,"12");}
 if(j==13){strcat(indice,"13");}
 if(j==14){strcat(indice,"14");}
 if(j==15){strcat(indice,"15");}
 if(j==16){strcat(indice,"16");}
 if(j==17){strcat(indice,"17");}
 if(j==18){strcat(indice,"18");}
 if(j==19){strcat(indice,"19");}
 if(j==20){strcat(indice,"20");}
 if(j==21){strcat(indice,"21");}
 if(j==22){strcat(indice,"22");}
 if(j==23){strcat(indice,"23");}
 if(j==24){strcat(indice,"24");}
 if(j==25){strcat(indice,"25");}
 if(j==26){strcat(indice,"26");}
 if(j==27){strcat(indice,"27");}
 if(j==28){strcat(indice,"28");}
 if(j==29){strcat(indice,"29");}
 if(j==30){strcat(indice,"30");}
 if(j==31){strcat(indice,"31");}
 if(j==32){strcat(indice,"32");}
 if(j==33){strcat(indice,"33");}
 if(j==34){strcat(indice,"34");}
 if(j==35){strcat(indice,"35");}
 if(j==36){strcat(indice,"36");}
 if(j==37){strcat(indice,"37");}
 if(j==38){strcat(indice,"38");}
 if(j==39){strcat(indice,"39");}
 if(j==40){strcat(indice,"40");}
 if(j==41){strcat(indice,"41");}
 if(j==42){strcat(indice,"42");}
 if(j==43){strcat(indice,"43");}
 if(j==44){strcat(indice,"44");}
 if(j==45){strcat(indice,"45");}
 if(j==46){strcat(indice,"46");}
 if(j==47){strcat(indice,"47");}
 if(j==48){strcat(indice,"48");}
 if(j==49){strcat(indice,"49");}
 if(j==50){strcat(indice,"50");}
 if(j==51){strcat(indice,"51");}
 if(j==52){strcat(indice,"52");}
 if(j==53){strcat(indice,"53");}
 if(j==54){strcat(indice,"54");}
 if(j==55){strcat(indice,"55");}
 if(j==56){strcat(indice,"56");}
 if(j==57){strcat(indice,"57");}
 if(j==58){strcat(indice,"58");}
 if(j==59){strcat(indice,"59");}
 if(j==60){strcat(indice,"60");}
 if(j==61){strcat(indice,"61");}
 if(j==62){strcat(indice,"62");}
 if(j==63){strcat(indice,"63");}
 if(j==64){strcat(indice,"64");}
 if(j==65){strcat(indice,"65");}
 if(j==66){strcat(indice,"66");}
 if(j==67){strcat(indice,"67");}
 if(j==68){strcat(indice,"68");}
 if(j==69){strcat(indice,"69");}
 if(j==70){strcat(indice,"70");}
 if(j==71){strcat(indice,"71");}
 if(j==72){strcat(indice,"72");}
 if(j==73){strcat(indice,"73");}
 if(j==74){strcat(indice,"74");}
 if(j==75){strcat(indice,"75");}
 if(j==76){strcat(indice,"76");}
 if(j==77){strcat(indice,"77");}
 if(j==78){strcat(indice,"78");}
 if(j==79){strcat(indice,"79");}
 if(j==80){strcat(indice,"80");}
 if(j==81){strcat(indice,"81");}
 if(j==82){strcat(indice,"82");}
 if(j==83){strcat(indice,"83");}
 if(j==84){strcat(indice,"84");}
 if(j==85){strcat(indice,"85");}
 if(j==86){strcat(indice,"86");}
 if(j==87){strcat(indice,"87");}
 if(j==88){strcat(indice,"88");}
 if(j==89){strcat(indice,"89");}
 if(j==90){strcat(indice,"90");}
 if(j==91){strcat(indice,"91");}
 if(j==92){strcat(indice,"92");}
 if(j==93){strcat(indice,"93");}
 if(j==94){strcat(indice,"94");}
 if(j==95){strcat(indice,"95");}
 if(j==96){strcat(indice,"96");}
 if(j==97){strcat(indice,"97");}
 if(j==98){strcat(indice,"98");}
 if(j==99){strcat(indice,"99");}
 if(j==100){strcat(indice,"100");}
}


* Archivos Programación  ([https://www.dropbox.com/sh/95c62k7iawww5zq/37UvAUy-Wf Descargar...])
* Archivos Fuente  ([https://www.dropbox.com/sh/95c62k7iawww5zq/37UvAUy-Wf  Descargar])

== Publicidad ==
* Archivos LOGO  ([http://www.example.com/archi11.zip  Descargar...])
* Archivos P  ([http://www.example.com/archi22.zip  Descargar...])

= BIBLIOGRAFIA =
* [1]Allison, E. (2013). ''Methane Hydrates Could be the Next Natural Gas Bonanza''. AAPG GEO-DC Blog. Recuperado de ([http://blog.aapg.org/geodc/?p=2935 Abrir ...])
* [2] Armstrong, D. ''Getting Started with BeagleBone Black''. (2013) ([http://www.circuidipity.com/getting-started-with-beaglebone-black.html Getting Start..])
* [3] eLinux.Puertos GPIO en Linux Embebido (2013) ([http://elinux.org/GPIO] Puertos GPIO)
* [4] Armstrong,d. "BeagleBone Black: 'Say Hello to My Little LEDs'" .(2013) ([http://www.circuidipity.com/bbb-led.html Configuración puertos BeagleBone Black])
* [5] Libreria en C para BeagleBone Black (2013) [http://www.element14.com/community/community/knode/single-board_computers/next-gen_beaglebone/blog/2013/10/10/bbb--beaglebone-black-io-library-for-c]
